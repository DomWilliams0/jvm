use std::fmt::{Debug, Formatter};

use log::*;

pub use item::{Index, Tag};

use crate::buffer::Buffer;
use crate::constant_pool::entry::Entry;
use crate::{ClassError, ClassResult};

pub mod attribute;
mod entry;
mod item;

pub struct ConstantPool<'c>(Vec<Option<Item<'c>>>);

pub use item::{ClassRefItem, Item, Utf8Item};

impl<'c> ConstantPool<'c> {
    pub(crate) fn empty() -> Self {
        ConstantPool(Vec::new())
    }

    pub(crate) fn load(buf: &mut Buffer<'c>) -> ClassResult<Self> {
        let count = buf.read::<u16>()? as usize;
        debug!("constant pool has {} entries", count);

        let mut constants = Vec::with_capacity(count);
        constants.resize_with(count, Default::default);

        let slice = &mut constants[..count]; // len hint for compiler

        let mut index = 1;
        while index < count {
            let item = Item::load(buf)?;
            let wide = item.is_wide();

            trace!("{}) got item {:?}", index, item);
            slice[index - 1] = Some(item);

            index += if wide { 2 } else { 1 };
        }

        Ok(Self(constants))
    }

    pub fn entries(&self) -> impl Iterator<Item = (u16, &Item)> {
        self.0
            .iter()
            .enumerate()
            .filter_map(|(i, item)| item.as_ref().map(|item| ((i + 1) as u16, item)))
    }

    /// Valid entry count
    pub fn count(&self) -> usize {
        self.entries().count()
    }

    /// Entry count including unoccupied
    pub fn size(&self) -> usize {
        self.0.len()
    }

    fn item(&self, idx: Index) -> Option<&'c Item> {
        // adjust for 1-indexing
        let idx = (idx - 1) as usize;
        self.0.get(idx).and_then(|i| i.as_ref())
    }

    pub fn entry<E: Entry + 'static>(&self, index: Index) -> ClassResult<&E> {
        let item = self.item(index).ok_or_else(|| ClassError::CpIndex(index))?;
        item.to_entry().ok_or_else(|| ClassError::CpEntry {
            index,
            actual: item.tag(),
            expected: E::TAG,
        })
    }

    pub fn string_entry(&self, index: Index) -> ClassResult<&'c mutf8::mstr> {
        self.entry::<Utf8Item>(index).map(|item| item.string)
    }

    pub fn string_entry_utf8(&self, index: Index) -> ClassResult<String> {
        self.string_entry(index).map(|s| s.to_utf8().into_owned())
    }
}

impl Debug for ConstantPool<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConstantPool(")?;
        f.debug_list().entries(self.entries()).finish()?;
        write!(f, ")")
    }
}

#[cfg(test)]
mod tests {
    use crate::buffer::Buffer;
    use crate::constant_pool::{ClassRefItem, ConstantPool, Item, Tag, Utf8Item};

    fn pool() -> ConstantPool<'static> {
        const POOL: [u8; 636] = [
            0x00, 0x45, 0x0a, 0x00, 0x15, 0x00, 0x26, 0x0a, 0x00, 0x27, 0x00, 0x28, 0x09, 0x00,
            0x0d, 0x00, 0x29, 0x09, 0x00, 0x2a, 0x00, 0x2b, 0x07, 0x00, 0x2c, 0x0a, 0x00, 0x05,
            0x00, 0x26, 0x08, 0x00, 0x2d, 0x0a, 0x00, 0x05, 0x00, 0x2e, 0x0a, 0x00, 0x05, 0x00,
            0x2f, 0x0a, 0x00, 0x30, 0x00, 0x31, 0x06, 0x40, 0x09, 0x1e, 0xb8, 0x51, 0xeb, 0x85,
            0x1f, 0x07, 0x00, 0x32, 0x08, 0x00, 0x33, 0x0a, 0x00, 0x0d, 0x00, 0x34, 0x06, 0x40,
            0x44, 0x0f, 0xbe, 0x76, 0xc8, 0xb4, 0x39, 0x0a, 0x00, 0x0d, 0x00, 0x35, 0x0a, 0x00,
            0x30, 0x00, 0x36, 0x09, 0x00, 0x0d, 0x00, 0x37, 0x07, 0x00, 0x38, 0x01, 0x00, 0x05,
            0x66, 0x69, 0x65, 0x6c, 0x64, 0x01, 0x00, 0x12, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f,
            0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x3b, 0x01, 0x00,
            0x06, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x01, 0x00, 0x01, 0x49, 0x01, 0x00, 0x06,
            0x3c, 0x69, 0x6e, 0x69, 0x74, 0x3e, 0x01, 0x00, 0x15, 0x28, 0x4c, 0x6a, 0x61, 0x76,
            0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x3b,
            0x29, 0x56, 0x01, 0x00, 0x04, 0x43, 0x6f, 0x64, 0x65, 0x01, 0x00, 0x0f, 0x4c, 0x69,
            0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x01,
            0x00, 0x07, 0x64, 0x6f, 0x54, 0x68, 0x69, 0x6e, 0x67, 0x01, 0x00, 0x04, 0x28, 0x44,
            0x29, 0x44, 0x01, 0x00, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x01, 0x00, 0x16, 0x28, 0x5b,
            0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x53, 0x74, 0x72,
            0x69, 0x6e, 0x67, 0x3b, 0x29, 0x56, 0x01, 0x00, 0x08, 0x3c, 0x63, 0x6c, 0x69, 0x6e,
            0x69, 0x74, 0x3e, 0x01, 0x00, 0x03, 0x28, 0x29, 0x56, 0x01, 0x00, 0x0a, 0x53, 0x6f,
            0x75, 0x72, 0x63, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x01, 0x00, 0x0a, 0x44, 0x75, 0x6d,
            0x6d, 0x79, 0x2e, 0x6a, 0x61, 0x76, 0x61, 0x0c, 0x00, 0x1a, 0x00, 0x23, 0x07, 0x00,
            0x39, 0x0c, 0x00, 0x3a, 0x00, 0x3b, 0x0c, 0x00, 0x16, 0x00, 0x17, 0x07, 0x00, 0x3c,
            0x0c, 0x00, 0x3d, 0x00, 0x3e, 0x01, 0x00, 0x17, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c,
            0x61, 0x6e, 0x67, 0x2f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x42, 0x75, 0x69, 0x6c,
            0x64, 0x65, 0x72, 0x01, 0x00, 0x07, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x3a, 0x20, 0x0c,
            0x00, 0x3f, 0x00, 0x40, 0x0c, 0x00, 0x41, 0x00, 0x3b, 0x07, 0x00, 0x42, 0x0c, 0x00,
            0x43, 0x00, 0x1b, 0x01, 0x00, 0x05, 0x44, 0x75, 0x6d, 0x6d, 0x79, 0x01, 0x00, 0x07,
            0x61, 0x77, 0x65, 0x73, 0x6f, 0x6d, 0x65, 0x0c, 0x00, 0x1a, 0x00, 0x1b, 0x0c, 0x00,
            0x1e, 0x00, 0x1f, 0x0c, 0x00, 0x43, 0x00, 0x44, 0x0c, 0x00, 0x18, 0x00, 0x19, 0x01,
            0x00, 0x10, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x4f, 0x62,
            0x6a, 0x65, 0x63, 0x74, 0x01, 0x00, 0x10, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61,
            0x6e, 0x67, 0x2f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x01, 0x00, 0x0b, 0x74, 0x6f,
            0x55, 0x70, 0x70, 0x65, 0x72, 0x43, 0x61, 0x73, 0x65, 0x01, 0x00, 0x14, 0x28, 0x29,
            0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x53, 0x74, 0x72,
            0x69, 0x6e, 0x67, 0x3b, 0x01, 0x00, 0x10, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61,
            0x6e, 0x67, 0x2f, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x01, 0x00, 0x03, 0x6f, 0x75,
            0x74, 0x01, 0x00, 0x15, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x69, 0x6f, 0x2f, 0x50,
            0x72, 0x69, 0x6e, 0x74, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x3b, 0x01, 0x00, 0x06,
            0x61, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x01, 0x00, 0x2d, 0x28, 0x4c, 0x6a, 0x61, 0x76,
            0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x3b,
            0x29, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x53, 0x74,
            0x72, 0x69, 0x6e, 0x67, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x65, 0x72, 0x3b, 0x01, 0x00,
            0x08, 0x74, 0x6f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x01, 0x00, 0x13, 0x6a, 0x61,
            0x76, 0x61, 0x2f, 0x69, 0x6f, 0x2f, 0x50, 0x72, 0x69, 0x6e, 0x74, 0x53, 0x74, 0x72,
            0x65, 0x61, 0x6d, 0x01, 0x00, 0x07, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x6c, 0x6e, 0x01,
            0x00, 0x04, 0x28, 0x44, 0x29, 0x56,
        ];

        let mut buf = Buffer::new(&POOL);
        ConstantPool::load(&mut buf).expect("should succeed")
    }

    #[test]
    fn items() {
        let pool = pool();
        assert_eq!(pool.count(), 66);

        let item = pool.item(5).unwrap();
        assert_eq!(item.tag(), Tag::Class);
        match pool.item(5).unwrap() {
            Item::Class(ClassRefItem { name }) => assert_eq!(*name, 44),
            _ => unreachable!(),
        }

        assert!(pool.item(12).is_none()); // unusable because of Double before

        match pool.item(23).unwrap() {
            Item::Utf8(Utf8Item { string }) => assert_eq!(string.to_utf8(), "Ljava/lang/String;"),
            _ => unreachable!(),
        }
    }
    #[test]
    fn entries() {
        let pool = pool();

        let utf8: &Utf8Item = pool.entry(23).expect("should be utf8");
        assert_eq!(utf8.string.to_utf8(), "Ljava/lang/String;");

        assert!(pool.entry::<Utf8Item>(5).is_err());

        let (_, item) = pool.entries().find(|(i, _)| *i == 23).unwrap();
        let utf8_again: &Utf8Item = item.to_entry().expect("should be string");
        assert_eq!(utf8.string, utf8_again.string);
    }
}
